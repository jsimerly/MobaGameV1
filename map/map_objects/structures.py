from map.map_objects.base import StructureBase
from combat import HealthComponent, AttackComponent
from typing import Callable


class MainBase(StructureBase):
    def __init__(self, 
        sprite, 
        color:(int,int,int), #Will be team color eventually
        radius:int=2,
        health:int=1000,
        teleport_radius:int=3,
    ):
        super().__init__(
            'Main Base', 
            is_passable=False, 
            is_los=False, 
            is_concealing=False, 
            sprite=sprite
        )
        self.color = color
        self.radius = radius
        self.health_component = HealthComponent(health)
        self.teleport_radius = teleport_radius

    def teleport(self):
        #teleport
        pass

    def destroy(self):
        super().destroy()
        #End the game when this happens

class Teleporter(StructureBase):
    def __init__(self, 
        sprite, 
        color:(int,int,int), 
        health:int=500,
        teleport_radius:int=2

    ):
        super().__init__(
            'Teleporter', 
            is_passable=False, 
            is_los=False, 
            is_concealing=False, 
            sprite=sprite
        )
        self.color = color
        self.health_component = HealthComponent(health)
        self.teleport_radius = teleport_radius

    def teleport(self):
        #teleport
        pass

    def destroy(self):
        super().destroy()
        #increase the spawn timers +1

class Turret(StructureBase):
    def __init__(self, 
        sprite,  
        health:int=500,
        damage:int=200,
    ):
        super().__init__(
            'Turret', 
            is_passable=False, 
            is_los=False, 
            is_concealing=False, 
            sprite=sprite
        )

        self.health_component = HealthComponent(health)
        self.attack_component = AttackComponent(damage)

class PowerCrystal(StructureBase):
    def __init__(self, sprite):
        super().__init__(
            name='Power Crystal', 
            is_passable=False, 
            is_los=True, 
            is_concealing=False, 
            sprite=sprite,
        )

class PowerShards(StructureBase):
    def __init__(self, sprite):
        super().__init__(
            name='Power Shards', 
            is_passable=True, 
            is_los=True, 
            is_concealing=False, 
            sprite=sprite,
        )
    
class AltarBase(StructureBase):
    def __init__(self, 
            spawn_turn:int,
            control_points_needed:int,
            control_turns: int,
            max_turns:int,

            draw_function:Callable,
            draw_kwargs:dict,
            reward_function:Callable,

            name:str,
            sprite, 
            is_passable=False,
            is_los=True,
            is_conealing=False,
        ):
        super().__init__(
            name=name, 
            is_passable=is_passable, 
            is_los=is_los, 
            is_concealing=is_conealing, 
            sprite=sprite,
        )
        #These are generated by having someone standing in the ring
        self.control_points_needed = control_points_needed
        self.spawn_turn = spawn_turn
        self.control_turn = control_turns
        self.max_turns = max_turns

        self.draw_function = draw_function
        self.draw_kwargs = draw_kwargs
        self.reward_function = reward_function

        #consider moving this into a delegate if we want cps to persist to the next 'altar-cation'
        self.team_1_cps = 0
        self.team_2_cps = 0

        self.is_active = False
        self.is_complete = False

    def spawn(self):
        self.is_active=True
        self.draw()

    def draw(self):
        self.draw_function(**self.draw_kwargs)
    
    def check_for_altar_winner(self) -> (bool, str):
        t1_cps = self.team_1_cps
        t2_cps = self.team_2_cps

        if max(t1_cps, t2_cps) >= self.control_points_needed:
            if t2_cps < t1_cps:
                (True, 'team_2')
            if t1_cps > t2_cps:
                return (True, 'team_1')

    def despawn(self):
        self.is_active=True
        #undraw the object
            

    
    



    

    


